<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Alexandre Drawn</title>
    <style>
        /* General Styles */
        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden;
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            min-width: 600px;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
            overscroll-behavior: contain;
        }
        .main {
            flex: 1;
            display: flex;
            flex-direction: row;
            min-height: 0; /* Fix for flexbox overflow */
        }
        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding: 10px;
            background: #e0e0e0;
            justify-content: start;
            align-items: center;
        }
        .tools {
            padding: 10px;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            background: #f0f0f0;
            z-index: 3;
            align-items: center;
        }
        /* UI Elements */
        button, input[type="range"], select, #fillTool {
            padding: 0.5rem;
            cursor: pointer;
            border-radius: 5px;
            border: 1px solid #aaa;
            font-family: sans-serif;
            flex-shrink: 0; /* Prevent buttons from shrinking */
        }
        input[type="range"].vertical {
            writing-mode: bt-lr;
            -webkit-appearance: slider-vertical;
            height: 150px;
            margin-top: 15px; /* Added margin for labels */
        }
        .stacked {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        #toolSwitch, #fillTool {
            font-size: 1.5rem;
            cursor: pointer;
            background: white;
            border: 1px solid #aaa;
            border-radius: 5px;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
        }
        /* Canvas Container */
        #canvas-container {
            position: relative;
            flex: 1;
            overflow: hidden;
            min-width: 600px;
        }
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            touch-action: none;
            display: block;
            user-select: none;
            -webkit-user-select: none;
        }
        /* MODIFIED: Container for selection controls */
        #selection-controls {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 101;
            display: none; /* Hidden by default, controlled by JS */
            flex-direction: row;
            gap: 5px;
            align-items: center;
        }
        #fitToCanvasBtn {
            opacity: 0.9;
        }
        .selection-button {
            padding: 0.4rem;
            font-size: 1.2rem;
            background: #fff;
            border: 1px solid #777;
            border-radius: 5px;
            opacity: 0.9;
            cursor: pointer;
            display: block; /* Let the parent control visibility */
        }
        .selection-button:hover {
            background: #e0e0e0;
        }
        /* Timeline Section */
        #timeline-section {
            display: flex;
            background: #ddd;
            overflow-x: auto;
        }
        #timeline-controls {
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
            background: #f0f0f0;
            position: sticky;
            left: 0;
            z-index: 20;
            border-right: 1px solid #b0b0b0;
        }
        #timeline-controls .button-group {
            display: flex;
            align-items: center;
            padding: 4px;
            gap: 4px;
            height: 38px; /* Match frame height */
            box-sizing: border-box;
        }
        /* MODIFIED: Styling for Audio Track Controls */
        .audio-track-controls {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 8px;
            font-family: sans-serif;
            height: 38px; /* Match frame height */
            background: #c5c5c5;
            border-top: 1px solid #aaa;
            box-sizing: border-box;
            cursor: pointer;
        }
        .audio-track-controls.active {
            background: #a0c4ff; /* Highlight for active track */
            font-weight: bold;
        }
        .audio-track-controls span {
            color: #333;
            font-size: 0.9em;
        }
        #deleteAudioBtn {
            padding: 2px 6px;
            font-size: 1.2rem;
            background: #e7e7e7;
            border: 1px solid #aaa;
            cursor: pointer;
            border-radius: 4px;
            line-height: 1;
        }
        #deleteAudioBtn:hover {
            background: #d7d7d7;
        }
        #timeline-wrapper {
            position: relative;
            display: flex;
            flex-direction: column;
        }
        #timeline {
            display: flex;
            align-items: center;
            gap: 0; /* Remove gap, width will control spacing */
            padding: 4px 0;
            height: 38px;
            box-sizing: border-box;
        }
        #timeline img {
            height: 30px;
            object-fit: cover;
            cursor: pointer;
            border: 1px solid transparent;
            box-sizing: border-box;
            background: white;
            margin: 0; 
        }
        #timeline img.active {
            border-color: red;
            border-width: 2px;
        }
        #timeline img.dragging {
            opacity: 0.5;
        }
        /* MODIFIED: Container for all audio timelines */
        #audio-timelines-container {
            display: flex;
            flex-direction: column;
            position: relative;
        }
        .audio-timeline-container {
            height: 38px; /* Match frame height */
            position: relative;
            background: #c5c5c5;
            border-top: 1px solid #aaa;
        }
        .audio-track {
            position: relative;
            height: 100%;
            width: 900000px; 
        }
        #frame-markers {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            width: 100%;
            pointer-events: none;
            overflow: hidden;
        }
        .frame-marker {
            position: absolute;
            width: 1px;
            height: 100%;
            background-color: rgba(100, 100, 100, 0.4);
        }
        .audio-clip {
            position: absolute;
            top: 4px; /* Centered in 38px container */
            height: 30px;
            background: rgba(0, 150, 255, 0.6);
            border-radius: 4px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
            cursor: grab;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            border: 2px solid transparent;
        }
        .audio-clip.selected {
            border: 2px solid #ff4500;
            box-shadow: 0 0 5px #ff4500;
        }
        .audio-clip:active {
            cursor: grabbing;
            z-index: 12;
        }
        .audio-clip-waveform {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        .resize-handle {
            position: absolute;
            width: 8px;
            height: 100%;
            top: 0;
            z-index: 11;
        }
        .resize-handle.left {
            left: 0;
            cursor: e-resize;
        }
        .resize-handle.right {
            right: 0;
            cursor: w-resize;
        }
        #timeline-playhead {
            position: absolute;
            width: 2px;
            height: 100%; /* Spans full height of timeline-wrapper */
            top: 0;
            left: 0;
            background-color: rgba(255, 0, 0, 0.7);
            z-index: 100;
            pointer-events: none;
            display: none;
        }

        /* Toolbar Elements */
        #frameCounter {
            font-family: 'Comic Sans MS', cursive;
            font-size: 1rem;
            color: #444;
            margin-right: 5px;
            margin-left: 10px;
        }
        #animDuration {
            margin-left: 5px;
            margin-right: 10px;
        }
        #fpsSelect {
            margin-right: 5px;
        }
        footer {
            text-align: center;
            background: #f0f0f0;
            padding: 6px;
            font-size: 0.8rem;
        }
        .spacer {
            flex: 1;
        }
        /* Color Picker */
        #colorWrapper {
            position: relative;
        }
        #color {
            width: 40px;
            height: 40px;
            border-radius: 6px;
            border: 2px solid #555;
            cursor: pointer;
            padding: 0;
        }
        /* Active State for Buttons */
        #btnCut {
            padding: 0.5rem;
            border-radius: 5px;
            background: #ccc;
            border: 1px solid #aaa;
            cursor: pointer;
            user-select: none;
        }
        #btnCut.active {
            background: #28a745;
            color: white;
            border-color: #228b22;
        }
        #fillTool.active {
            background: #007bff;
            color: white;
            border-color: #0056b3;
        }
        #layerSwitchBtn.active-bg {
            background: #6c757d; /* Grey for BG */
            color: white;
            border-color: #5a6268;
        }
        #layerSwitchBtn.active-fg {
            background: #ffc107; /* Yellow for FG */
            border-color: #e0a800;
        }
        /* File Menu Dropdown */
        #fileMenuContainer {
            position: relative;
            display: inline-block;
        }
        #fileMenuBtn {
            background-color: #d0d0d0;
            font-weight: bold;
        }
        #fileMenuDropdown {
            position: absolute;
            background-color: #f1f1f1;
            min-width: 240px;
            box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
            z-index: 10;
            border-radius: 5px;
            padding: 5px 0;
            border: 1px solid #ccc;
            margin-top: 2px;
        }
        #fileMenuDropdown.hidden {
            display: none;
        }
        #fileMenuDropdown button {
            color: black;
            padding: 8px 16px;
            text-decoration: none;
            display: block;
            width: 100%;
            text-align: left;
            background: none;
            border: none;
            border-radius: 0;
        }
        #fileMenuDropdown button:hover {
            background-color: #ddd;
        }
        #fileMenuDropdown hr {
            margin: 4px 0;
            border: none;
            border-top: 1px solid #ccc;
        }
    </style>
</head>
<body>
    <div id="screenWarning" style="display:none; color: red; text-align: center; background: #fff9; position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 9999; font-size: 1.5rem; padding: 2rem; backdrop-filter: blur(2px); flex-direction: column;">
        Minimum requirement isn't enough :(<br>
        Please use a larger screen.
    </div>

    <div class="tools">
        <div id="fileMenuContainer">
            <button id="fileMenuBtn">üìÅ File</button>
            <div id="fileMenuDropdown" class="hidden">
                <button id="openProject">üìÇ Open Project</button>
                <button id="saveProject">üíæ Save Project</button>
                <hr>
                <button id="importAudio">üéµ Import Audio</button>
                <hr>
                <button id="saveZip">üì¶ Save as ZIP</button>
                <button id="saveTransparentZipBtn">üì¶ Save as Transparent ZIP</button> 
                <hr>
                <button id="saveMp4">üé¨ Save as WebM</button>
                <button id="saveTransparentMp4Btn">üé¨ Save as Transparent WebM</button> 
            </div>
        </div>
        
        <span id="frameCounter">Frame: 1</span>
        <span id="animDuration"></span>
        <label for="fpsSelect" style="margin-left: 10px;">FPS:</label>
        <select id="fpsSelect"></select>
        <button id="clearAll">Clear All</button>
        <button id="importImage">üñºÔ∏è Import Image</button>

        <input type="file" id="imageLoader" style="display:none;" accept="image/*" />
        <input type="file" id="audioLoader" style="display:none;" accept="audio/*" />
        <input type="file" id="projectLoader" style="display:none;" accept=".json,application/json" />
        
        <button id="layerSwitchBtn">‚úèÔ∏è Drawing Layer</button>
        <select id="brushType">
            <option value="pen">üñäÔ∏è Pen</option>
            <option value="crayon">üñçÔ∏è Crayon</option>
            <option value="watercolor">üñåÔ∏è Watercolor</option>
            <option value="charcoal">ü™µ Charcoal</option>
            <option value="spray">‚ú® Spray</option>
            <option value="light">üåü Light</option>
        </select>
        <button id="btnCut">Select/Move</button>
        <div id="fillTool" title="Fill Tool">ü™£</div>
        <label for="toleranceRange">Fill Tolerance:</label>
        <input type="range" id="toleranceRange" min="0" max="255" value="150" step="1" />
        <span id="toleranceValue">150</span>
        <div class="spacer"></div>
        <div id="colorWrapper">
            <input type="color" id="color" value="#000000" />
        </div>
    </div>
    <div class="main">
        <div class="sidebar">
            <input type="range" id="size" min="1" max="100" value="5" class="vertical" list="size-ticks" />
            <datalist id="size-ticks">
                <option value="1"></option>
                <option value="5"></option>
                <option value="10"></option>
                <option value="15"></option>
                <option value="25"></option>
                <option value="50"></option>
                <option value="75"></option>
                <option value="100"></option>
            </datalist>
            <div id="toolSwitch" title="Switch Tool (Brush/Eraser)">üñåÔ∏è</div>
            <input type="range" id="opacityRange" min="0" max="1" step="0.05" value="0.3" class="vertical" />
            <div class="stacked">
                <button id="undo">Undo</button>
                <button id="redo">Redo</button>
            </div>
        </div>
        <div id="canvas-container">
            <div id="selection-controls">
                <button id="fitToCanvasBtn">Fit</button>
                <button id="copySelectionBtn" title="Copy (Ctrl+C)" class="selection-button">üìÑ</button>
                <button id="pasteSelectionBtn" title="Paste (Ctrl+V)" class="selection-button">üìã</button>
                <button id="flipHorizontalBtn" title="Flip Horizontal" class="selection-button">‚ÜîÔ∏è</button>
                <button id="flipVerticalBtn" title="Flip Vertical" class="selection-button">‚ÜïÔ∏è</button>
            </div>
        </div>
    </div>
    <div id="timeline-section">
        <div id="timeline-controls">
            <div class="button-group">
                <button id="addFrame">‚ûï Add Frame</button>
                <button id="duplicateFrame">üìÑ Duplicate Frame</button>
                <button id="deleteFrame">üóëÔ∏è Delete Frame</button>
                <button id="play">‚ñ∂Ô∏è Play</button>
                <button id="deleteAudioBtn" title="Delete Selected Audio" style="display: none;">üóëÔ∏è</button>
            </div>
        </div>
        <div id="timeline-wrapper">
            <div id="timeline"></div>
            <div id="audio-timelines-container">
                <div id="frame-markers"></div>
            </div>
            <div id="timeline-playhead"></div>
        </div>
    </div>
    <footer>Made by Alexandre Rossi Alves</footer>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js"></script>
    <script>
        // === DOM Element Variables ===
        const container = document.getElementById('canvas-container');
        // MODIFIED: Get the new selection controls container
        const selectionControls = document.getElementById('selection-controls');
        const fitToCanvasBtn = document.getElementById('fitToCanvasBtn');
        const copySelectionBtn = document.getElementById('copySelectionBtn');
        const pasteSelectionBtn = document.getElementById('pasteSelectionBtn');
        // NEW: Flip Buttons
        const flipHorizontalBtn = document.getElementById('flipHorizontalBtn');
        const flipVerticalBtn = document.getElementById('flipVerticalBtn');

        const timelineSection = document.getElementById('timeline-section');
        const timelineControls = document.getElementById('timeline-controls');
        const timelineWrapper = document.getElementById('timeline-wrapper');
        const timeline = document.getElementById('timeline');
        const audioTimelinesContainer = document.getElementById('audio-timelines-container');
        const timelinePlayhead = document.getElementById('timeline-playhead');
        const frameCounter = document.getElementById('frameCounter');
        const colorInput = document.getElementById('color');
        const sizeInput = document.getElementById('size');
        const undoBtn = document.getElementById('undo');
        const redoBtn = document.getElementById('redo');
        const clearAllBtn = document.getElementById('clearAll');
        const importImageBtn = document.getElementById('importImage');
        const imageLoader = document.getElementById('imageLoader');
        const addFrameBtn = document.getElementById('addFrame');
        const duplicateBtn = document.getElementById('duplicateFrame');
        const deleteBtn = document.getElementById('deleteFrame');
        const playBtn = document.getElementById('play');
        const opacitySlider = document.getElementById('opacityRange');
        const toolSwitch = document.getElementById('toolSwitch');
        const fillTool = document.getElementById('fillTool');
        const brushType = document.getElementById('brushType');
        const btnCut = document.getElementById('btnCut');
        const fpsSelect = document.getElementById('fpsSelect');
        const toleranceRange = document.getElementById('toleranceRange');
        const toleranceValue = document.getElementById('toleranceValue');
        const layerSwitchBtn = document.getElementById('layerSwitchBtn');
        const projectLoader = document.getElementById('projectLoader');
        let tolerance = parseInt(toleranceRange.value);

        // === Menu dropdown elements and their corresponding buttons ===
        const fileMenuBtn = document.getElementById('fileMenuBtn');
        const fileMenuContainer = document.getElementById('fileMenuContainer');
        const fileMenuDropdown = document.getElementById('fileMenuDropdown');
        const openProjectBtn = document.getElementById('openProject');
        const saveProjectBtn = document.getElementById('saveProject');
        const importAudioBtn = document.getElementById('importAudio');
        const saveZipBtn = document.getElementById('saveZip');
        const saveMp4Btn = document.getElementById('saveMp4');
        // NEW: Get the new export buttons
        const saveTransparentZipBtn = document.getElementById('saveTransparentZipBtn');
        const saveTransparentMp4Btn = document.getElementById('saveTransparentMp4Btn');
        
        // === Audio DOM and State Variables ===
        const audioLoader = document.getElementById('audioLoader');
        const frameMarkersContainer = document.getElementById('frame-markers');
        let deleteAudioBtn = document.getElementById('deleteAudioBtn'); // Get static button
        const NUM_AUDIO_TRACKS = 3;
        let audioContext = null;
        let audioClips = Array.from({ length: NUM_AUDIO_TRACKS }, () => []); // Array of arrays for each track
        let activeAudioTrack = 0; // The currently selected track index
        let activeAudioSources = []; // To stop them later
        let dragInfo = {}; // To manage dragging of audio clips and handles
        let selectedAudioClip = null; // Will store { id, trackIndex }

        // === General State Variables ===
        const PIXELS_PER_SECOND = 450;
        const VISUAL_FPS = 12; 
        const FRAME_WIDTH_PX = PIXELS_PER_SECOND / VISUAL_FPS;
        let tool = 'brush';
        let activeLayer = 'draw';
        const layerOrder = ['bg', 'draw', 'fg'];
        let frames = [];
        let currentFrame = 0;
        let drawing = false;
        let hasDrawn = false;
        let playing = false;
        let lastX = null, lastY = null;
        let fps = 12; // Playback FPS
        let frameDuration = 1000 / fps;
        let draggedIndex = null; 
        let isImportingImage = false;
        let animationFrameId = null;
        let recordingLoopId = null; // ID for the recording requestAnimationFrame loop
        let isRecording = false; // Flag to control recording state


        // === Selection/Cut State Variables ===
        let clipboard = null; // For copy-paste
        let mode = 'brush';
        let isSelecting = false;
        let selectionPath = [];
        let selectionImage = null;
        let selectionBBox = null;
        let dragging = false;
        let resizing = false;
        let rotating = false;
        let resizeDir = null;
        let dragOffset = { x:0, y:0, originalX: 0, originalY: 0, originalWidth: 0, originalHeight: 0, originalRotation: 0 };
        let selectionPos = {x:0, y:0};
        let selectionSize = {width:0, height:0};
        let selectionRotation = 0;
        let rotationStartAngle = 0;
        let preFitState = null;
        const HANDLE_SIZE = 10;
        const ROTATE_HANDLE_RADIUS = 8;
        const ROTATE_HANDLE_DIST = 20;

        // === Initial Setup ===
        container.addEventListener('gesturestart', e => e.preventDefault());
        container.addEventListener('gesturechange', e => e.preventDefault());
        container.addEventListener('gestureend', e => e.preventDefault());
        container.addEventListener('touchstart', e => e.preventDefault(), { passive: false });
        container.addEventListener('touchmove', e => e.preventDefault(), { passive: false });
        container.addEventListener('touchend', e => e.preventDefault(), { passive: false });
        let lastTouch = 0;
        container.addEventListener('touchend', function(e) {
            const now = Date.now();
            if (now - lastTouch <= 300) { e.preventDefault(); }
            lastTouch = now;
        }, false);

        toleranceRange.oninput = () => {
            tolerance = parseInt(toleranceRange.value);
            toleranceValue.innerText = tolerance;
        };

        for (let i = 1; i <= 24; i++) {
            const option = document.createElement('option');
            option.value = i;
            option.text = i;
            fpsSelect.appendChild(option);
        }
        fpsSelect.value = fps;

        // === Helper Functions for Timeline Scaling ===
        function timeToPx(time) {
            return time * fps * FRAME_WIDTH_PX;
        }

        function pxToTime(px) {
            const denominator = fps * FRAME_WIDTH_PX;
            if (denominator === 0) return 0;
            return px / denominator;
        }

        // === UI Functions ===
        function showNotification(message, duration = 3000) {
            let notification = document.getElementById('notification-popup');
            if (!notification) {
                notification = document.createElement('div');
                notification.id = 'notification-popup';
                Object.assign(notification.style, {
                    position: 'fixed', bottom: '20px', left: '50%', transform: 'translateX(-50%)',
                    padding: '10px 20px', background: 'rgba(0,0,0,0.75)', color: 'white',
                    borderRadius: '8px', zIndex: '9999', transition: 'opacity 0.5s, bottom 0.5s',
                    opacity: '0', pointerEvents: 'none'
                });
                document.body.appendChild(notification);
            }
            notification.textContent = message;
            notification.style.opacity = '1';
            notification.style.bottom = '20px';
            setTimeout(() => {
                notification.style.opacity = '0';
                notification.style.bottom = '0px';
            }, duration);
        }

        function showConfirm(message, onConfirm, onCancel) {
            const existingDialog = document.getElementById('confirm-dialog');
            if (existingDialog) existingDialog.remove();
            const overlay = document.createElement('div');
            overlay.id = 'confirm-dialog';
            Object.assign(overlay.style, {
                position: 'fixed', top: '0', left: '0', width: '100vw', height: '100vh',
                backgroundColor: 'rgba(0,0,0,0.5)', display: 'flex', justifyContent: 'center',
                alignItems: 'center', zIndex: '10000'
            });
            const box = document.createElement('div');
            Object.assign(box.style, {
                background: 'white', padding: '25px', borderRadius: '8px',
                textAlign: 'center', boxShadow: '0 4px 15px rgba(0,0,0,0.25)',
                maxWidth: '90%', width: '320px'
            });
            const msg = document.createElement('p');
            msg.textContent = message;
            msg.style.marginBottom = '20px';
            msg.style.fontSize = '1.1rem';
            box.appendChild(msg);
            const btnContainer = document.createElement('div');
            Object.assign(btnContainer.style, { display: 'flex', gap: '10px', justifyContent: 'center' });
            const confirmBtn = document.createElement('button');
            confirmBtn.textContent = 'Yes';
            confirmBtn.onclick = () => { if(onConfirm) onConfirm(); overlay.remove(); };
            const cancelBtn = document.createElement('button');
            cancelBtn.textContent = 'No';
            cancelBtn.onclick = () => { if(onCancel) onCancel(); overlay.remove(); };
            [cancelBtn, confirmBtn].forEach(btn => {
                btn.style.padding = '8px 20px';
                btn.style.border = '1px solid #ccc';
                btn.style.borderRadius = '5px';
                btn.style.cursor = 'pointer';
            });
            confirmBtn.style.background = '#28a745';
            confirmBtn.style.color = 'white';
            confirmBtn.style.borderColor = '#228b22';
            btnContainer.appendChild(cancelBtn);
            btnContainer.appendChild(confirmBtn);
            box.appendChild(btnContainer);
            overlay.appendChild(box);
            document.body.appendChild(overlay);
        }

        function updateToolUI() {
            fillTool.classList.toggle('active', tool === 'fill');
            btnCut.classList.toggle('active', mode === 'cut' || mode === 'move');
        }

        fpsSelect.onchange = () => {
            fps = parseInt(fpsSelect.value);
            frameDuration = 1000 / fps;
            updateAnimDuration();
            renderAllAudioTimelines();
        };
        
        layerSwitchBtn.onclick = () => {
            const currentIndex = layerOrder.indexOf(activeLayer);
            const nextIndex = (currentIndex + 1) % layerOrder.length;
            activeLayer = layerOrder[nextIndex];
            updateLayerButtonUI();
        };

        function updateLayerButtonUI() {
            layerSwitchBtn.classList.remove('active-bg', 'active-fg');
            if (activeLayer === 'bg') {
                layerSwitchBtn.innerText = 'üñºÔ∏è BG Layer';
                layerSwitchBtn.classList.add('active-bg');
            } else if (activeLayer === 'draw') {
                layerSwitchBtn.innerText = '‚úèÔ∏è Drawing Layer';
            } else if (activeLayer === 'fg') {
                layerSwitchBtn.innerText = 'üåü FG Layer';
                layerSwitchBtn.classList.add('active-fg');
            }
        }

        toolSwitch.onclick = () => {
            if(mode !== 'brush') return;
            if (tool === 'fill') tool = 'brush';
            tool = tool === 'brush' ? 'eraser' : 'brush';
            toolSwitch.innerText = tool === 'brush' ? 'üñåÔ∏è' : 'üßº';
            updateToolUI();
        };

        fillTool.onclick = () => {
            if(mode !== 'brush') return;
            tool = (tool === 'fill') ? 'brush' : 'fill';
            if (tool === 'fill') toolSwitch.innerText = 'üñåÔ∏è';
            updateToolUI();
        };

        colorInput.oninput = () => colorInput.style.backgroundColor = colorInput.value;
        colorInput.style.backgroundColor = colorInput.value;
        
        // === Canvas and Frame Management ===
        function createLayeredCanvas() {
            const w = container.clientWidth;
            const h = container.clientHeight;
            const canvases = {};
            layerOrder.forEach((layer, i) => {
                // Insert canvases before the selection controls
                const canvas = document.createElement('canvas');
                canvas.width = w; canvas.height = h;
                canvas.style.zIndex = i + 1;
                const ctx = canvas.getContext('2d');
                container.insertBefore(canvas, selectionControls);
                canvases[`${layer}Canvas`] = canvas;
                canvases[`${layer}Ctx`] = ctx;
            });
            return canvases;
        }

        function updateTimeline() {
            const activeDrawCanvas = frames[currentFrame]?.drawCanvas;
            timeline.innerHTML = '';
            frames.forEach((f, i) => {
                const thumb = document.createElement('img');
                thumb.style.width = `${FRAME_WIDTH_PX}px`;
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = f.bgCanvas.width;
                tempCanvas.height = f.bgCanvas.height;
                const tempCtx = tempCanvas.getContext('2d');
                layerOrder.forEach(layer => tempCtx.drawImage(f[`${layer}Canvas`], 0, 0));
                thumb.src = tempCanvas.toDataURL();
                thumb.draggable = true;
                thumb.dataset.index = i;
                if(f.drawCanvas === activeDrawCanvas) {
                    thumb.classList.add('active');
                    currentFrame = i;
                }
                thumb.onclick = () => switchToFrame(i);
                timeline.appendChild(thumb);
            });
            if(frames.some(f => f.drawCanvas === activeDrawCanvas)) {
                frameCounter.innerText = `Frame: ${currentFrame + 1}`;
            }
            updateAnimDuration();
            drawFrameMarkers();
        }
        
        function updateAnimDuration() {
            const duration = frames.length / fps;
            document.getElementById('animDuration').innerText = `‚è±Ô∏è ${duration.toFixed(2)}s`;
        }
        
        function checkScreenSize() {
            // Using reasonable pixel thresholds that approximate a 12-inch screen (e.g., common laptop/large tablet landscape resolutions)
            // A typical 12-inch screen might have ~1000px width in CSS pixels.
            const minWidth = 1400; // Example: equivalent to ~10.4 inches at 96dpi
            const minHeight = 800; // Example: equivalent to ~5.8 inches at 96dpi for 16:9 aspect ratio

            const isSmall = window.innerWidth < minWidth || window.innerHeight < minHeight;
            const screenWarningDiv = document.getElementById('screenWarning');
            const bodyChildren = Array.from(document.body.children);

            if (isSmall) {
                screenWarningDiv.style.display = "flex";
                screenWarningDiv.style.alignItems = "center";
                screenWarningDiv.style.justifyContent = "center";
                // Hide all other elements if the screen is too small
                bodyChildren.forEach(child => {
                    if (child.id !== 'screenWarning') {
                        child.style.display = 'none';
                    }
                });
            } else {
                screenWarningDiv.style.display = "none";
                // Restore display for all other elements if the screen is large enough
                document.querySelector('.tools').style.display = 'flex';
                document.querySelector('.main').style.display = 'flex';
                document.querySelector('#timeline-section').style.display = 'flex';
                document.querySelector('footer').style.display = 'block';
            }
        }
        window.addEventListener('resize', checkScreenSize);

        function switchToFrame(index, isPlaying = false) {
            if (index < 0 || index >= frames.length) return;
            frameCounter.innerText = `Frame: ${index + 1}`;
            const op = parseFloat(opacitySlider.value);
            frames.forEach((f, i) => {
                const isCurrent = (i === index);
                const isPrevious = (i === index - 1);
                layerOrder.forEach((layer, z) => {
                    const canvas = f[`${layer}Canvas`];
                    canvas.style.display = 'none';
                    if (isCurrent) {
                        canvas.style.display = 'block';
                        canvas.style.opacity = 1;
                        canvas.style.zIndex = (z + 1) * 2;
                    } else if (isPrevious) {
                        canvas.style.display = 'block';
                        canvas.style.opacity = op;
                        canvas.style.zIndex = z + 1;
                    }
                });
            });
            selCanvas.style.zIndex = (layerOrder.length * 2) + 1;
            currentFrame = index;
            if (!isPlaying) {
                updateTimeline();
            } else {
                timeline.querySelectorAll('img').forEach((thumb, i) => {
                    thumb.classList.toggle('active', i === index);
                });
            }
        }

        addFrameBtn.onclick = () => {
            const newCanvases = createLayeredCanvas();
            const newFrame = { ...newCanvases, history: [], redo: [] };
            frames.splice(currentFrame + 1, 0, newFrame);
            switchToFrame(currentFrame + 1);
            saveState();
        };

        duplicateBtn.onclick = () => {
            if (!frames[currentFrame]) return;
            const cur = frames[currentFrame];
            const newCanvases = createLayeredCanvas();
            layerOrder.forEach(layer => {
                newCanvases[`${layer}Ctx`].drawImage(cur[`${layer}Canvas`], 0, 0);
            });
            const newFrame = { ...newCanvases, history: [], redo: [] };
            frames.splice(currentFrame + 1, 0, newFrame);
            switchToFrame(currentFrame + 1);
            saveState();
        };

        deleteBtn.onclick = () => {
            if (frames.length <= 1) return;
            const frameToDelete = frames.splice(currentFrame, 1)[0];
            layerOrder.forEach(layer => container.removeChild(frameToDelete[`${layer}Canvas`]));
            currentFrame = Math.max(0, currentFrame - 1);
            switchToFrame(currentFrame);
            saveState();
        };

        playBtn.onclick = () => {
            if (playing) {
                playing = false;
                playBtn.innerText = "‚ñ∂Ô∏è Play";
                timelinePlayhead.style.display = 'none';
                if (animationFrameId) cancelAnimationFrame(animationFrameId);
                activeAudioSources.forEach(source => { try { source.stop(); } catch(e) {} });
                activeAudioSources = [];
                timeline.querySelectorAll('img').forEach((thumb, i) => {
                    thumb.classList.toggle('active', i === currentFrame);
                });
                return;
            }
            if (frames.length === 0) return;
            playing = true;
            playBtn.innerText = "‚èπÔ∏è Stop";
            timelinePlayhead.style.display = 'block';
            const animationTotalDuration = (frames.length / fps) * 1000;
            const startTime = performance.now();
            const audioStartTime = audioContext ? audioContext.currentTime : 0;
            activeAudioSources = [];
            if (audioContext) {
                const allClips = audioClips.flat(); // Play clips from all tracks
                allClips.forEach(clip => {
                    const source = audioContext.createBufferSource();
                    source.buffer = clip.buffer;
                    source.connect(audioContext.destination);
                    source.start(audioStartTime + clip.timelineStart, clip.clipStart, clip.clipDuration);
                    activeAudioSources.push(source);
                });
            }
            let lastFrameIndex = -1;
            function playbackLoop() {
                if (!playing) return;
                const elapsed = performance.now() - startTime;
                if (elapsed >= animationTotalDuration) {
                    playBtn.click();
                    return;
                }
                const newFrameIndex = Math.floor(elapsed / frameDuration);
                if (newFrameIndex !== lastFrameIndex && newFrameIndex < frames.length) {
                    lastFrameIndex = newFrameIndex;
                    switchToFrame(newFrameIndex, true); 
                }
                const playheadPos = timeToPx(elapsed / 1000);
                timelinePlayhead.style.left = `${playheadPos}px`;
                animationFrameId = requestAnimationFrame(playbackLoop);
            }
            animationFrameId = requestAnimationFrame(playbackLoop);
        };
        
        // === History (Undo/Redo) Management ===
        function saveState() {
            if (!frames[currentFrame]) return;
            const f = frames[currentFrame];
            const historyEntry = {
                selectionState: null,
                mode: mode,
                tool: tool,
                activeLayer: activeLayer
            };
            layerOrder.forEach(layer => {
                historyEntry[`${layer}ImageData`] = f[`${layer}Ctx`].getImageData(0, 0, f[`${layer}Canvas`].width, f[`${layer}Canvas`].height);
            });
            if (mode === 'move' && selectionImage) {
                historyEntry.selectionState = {
                    image: selectionImage,
                    pos: { ...selectionPos },
                    size: { ...selectionSize },
                    rotation: selectionRotation,
                    preFit: preFitState ? { pos: { ...preFitState.pos }, size: { ...preFitState.size } } : null
                };
            }
            if (f.history.length > 50) f.history.shift();
            f.history.push(historyEntry);
            f.redo = [];
        }

        function applyHistoryState(state) {
            if (!state) return;
            const f = frames[currentFrame];
            layerOrder.forEach(layer => {
                if (state[`${layer}ImageData`]) f[`${layer}Ctx`].putImageData(state[`${layer}ImageData`], 0, 0);
            });
            mode = state.mode;
            tool = state.tool;
            activeLayer = state.activeLayer || 'draw';
            updateLayerButtonUI();
            if (state.selectionState) {
                selectionImage = state.selectionState.image;
                selectionPos = state.selectionState.pos;
                selectionSize = state.selectionState.size;
                selectionRotation = state.selectionState.rotation;
                preFitState = state.selectionState.preFit;
                selCanvas.style.pointerEvents = 'auto';
            } else {
                selectionImage = null;
                preFitState = null;
                toolSwitch.style.pointerEvents = 'auto';
                fillTool.style.pointerEvents = 'auto';
                selCanvas.style.pointerEvents = 'none';
            }
            toolSwitch.innerText = tool === 'eraser' ? 'üßº' : 'üñåÔ∏è';
            updateToolUI();
            redrawSelection();
            updateTimeline();
        }

        undoBtn.onclick = () => {
            if (!frames[currentFrame] || frames[currentFrame].history.length < 2) return;
            const f = frames[currentFrame];
            f.redo.push(f.history.pop());
            applyHistoryState(f.history[f.history.length - 1]);
        };

        redoBtn.onclick = () => {
            if (!frames[currentFrame] || frames[currentFrame].redo.length === 0) return;
            const f = frames[currentFrame];
            const nextState = f.redo.pop();
            f.history.push(nextState);
            applyHistoryState(nextState);
        };

        // === Drawing Logic ===
        function getActiveContextAndCanvas() {
            if (!frames[currentFrame]) return { ctx: null, canvas: null };
            const f = frames[currentFrame];
            return { ctx: f[`${activeLayer}Ctx`], canvas: f[`${activeLayer}Canvas`] };
        }
        
        function draw(e) {
            if (mode !== 'brush' || !drawing || playing || !frames[currentFrame]) return;
            const { ctx, canvas } = getActiveContextAndCanvas();
            if (!ctx) return;
            const rect = canvas.getBoundingClientRect();
            const currentX = e.touches ? e.touches[0].clientX - rect.left : e.clientX - rect.left;
            const currentY = e.touches ? e.touches[0].clientY - rect.top : e.clientY - rect.top;
            const size = parseInt(sizeInput.value);
            const brush = brushType.value;
            ctx.globalCompositeOperation = tool === 'eraser' ? 'destination-out' : 'source-over';
            ctx.fillStyle = tool === 'eraser' ? 'rgba(0,0,0,1)' : colorInput.value;
            ctx.strokeStyle = tool === 'eraser' ? 'rgba(0,0,0,1)' : colorInput.value;
            if (brush === 'pen') {
                if (lastX !== null && lastY !== null) {
                    ctx.beginPath(); ctx.moveTo(lastX, lastY); ctx.lineTo(currentX, currentY);
                    ctx.lineWidth = size; ctx.lineCap = "round"; ctx.lineJoin = "round"; ctx.stroke();
                } else {
                    ctx.beginPath(); ctx.arc(currentX, currentY, size / 2, 0, Math.PI * 2); ctx.fill();
                }
                lastX = currentX; lastY = currentY;
            } else if (brush === 'crayon' || brush === 'light') {
                if (lastX !== null && lastY !== null) {
                    ctx.save();
                    ctx.lineCap = "round"; ctx.lineJoin = "round";
                    const dist = Math.hypot(currentX - lastX, currentY - lastY);
                    const angle = Math.atan2(currentY - lastY, currentX - lastX);
                    if (brush === 'light') {
                        const path = new Path2D(); path.moveTo(lastX, lastY); path.lineTo(currentX, currentY);
                        ctx.strokeStyle = colorInput.value; ctx.lineWidth = size;
                        ctx.shadowColor = colorInput.value; ctx.shadowBlur = size * 3; ctx.stroke(path);
                        ctx.shadowBlur = 0; ctx.lineWidth = size * 0.6; ctx.stroke(path);
                    } else {
                        for (let i = 0; i < dist; i += 1) {
                            const x = lastX + Math.cos(angle) * i; const y = lastY + Math.sin(angle) * i;
                            for (let j = 0; j < 10; j++) {
                                const offsetX = (Math.random() - 0.5) * size * 0.9;
                                const offsetY = (Math.random() - 0.5) * size * 0.9;
                                if (Math.hypot(offsetX, offsetY) < size * 0.5) {
                                    ctx.fillStyle = colorInput.value; ctx.globalAlpha = Math.random() * 0.25 + 0.15;
                                    ctx.fillRect(x + offsetX, y + offsetY, Math.random() * 2 + 1, Math.random() * 2 + 1);
                                }
                            }
                        }
                    }
                    ctx.restore();
                }
                lastX = currentX; lastY = currentY;
            } else { // Watercolor, Charcoal, Spray
                const density = brush === 'spray' ? 30 : (brush === 'charcoal' ? 25 : 5);
                for (let i = 0; i < density; i++) {
                    let offsetX = 0, offsetY = 0, radius = 0;
                    if (brush === 'spray') {
                        const angle = Math.random() * Math.PI * 2; radius = Math.random() * size / 1.5;
                        offsetX = Math.cos(angle) * radius; offsetY = Math.sin(angle) * radius;
                        ctx.globalAlpha = Math.random() * 0.5 + 0.2; ctx.fillRect(currentX + offsetX, currentY + offsetY, 1, 1);
                    } else if (brush === 'charcoal') {
                        offsetX = (Math.random() - 0.5) * size * 1.5; offsetY = (Math.random() - 0.5) * size * 1.5;
                        if (Math.sqrt(offsetX * offsetX + offsetY * offsetY) <= size * 0.75) {
                            ctx.globalAlpha = Math.random() * 0.2 + 0.1;
                            ctx.fillRect(currentX + offsetX, currentY + offsetY, Math.random() * 2 + 1, Math.random() * 2 + 1);
                        }
                    } else { // watercolor
                        offsetX = (Math.random() - 0.5) * size * 0.8; offsetY = (Math.random() - 0.5) * size * 0.8;
                        radius = size / 2 + Math.random() * (size / 2);
                        ctx.globalAlpha = 0.1; ctx.beginPath(); ctx.arc(currentX + offsetX, currentY + offsetY, radius, 0, Math.PI * 2); ctx.fill();
                    }
                }
                ctx.globalAlpha = 1.0;
            }
            hasDrawn = true;
        }

        function floodFill(startX, startY, fillColor) {
            if (!frames[currentFrame]) return;
            const { ctx, canvas } = getActiveContextAndCanvas();
            if (!ctx) return;
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            const {width, height} = canvas;
            const startNode = (startY * width + startX) * 4;
            const [startR, startG, startB, startA] = [data[startNode], data[startNode+1], data[startNode+2], data[startNode+3]];
            const r = parseInt(fillColor.slice(1,3),16), g = parseInt(fillColor.slice(3,5),16), b = parseInt(fillColor.slice(5,7),16);
            if (startR === r && startG === g && startB === b && startA === 255) return;
            saveState();
            const q = [[startX, startY]];
            while (q.length > 0) {
                const [x, y] = q.shift();
                if (x < 0 || x >= width || y < 0 || y >= height) continue;
                const idx = (y * width + x) * 4;
                if(data[idx]===r && data[idx+1]===g && data[idx+2]===b && data[idx+3]===255) continue;
                const diff = Math.abs(data[idx]-startR) + Math.abs(data[idx+1]-startG) + Math.abs(data[idx+2]-startB) + Math.abs(data[idx+3]-startA);
                if (diff <= tolerance) {
                    data[idx]=r; data[idx+1]=g; data[idx+2]=b; data[idx+3]=255;
                    q.push([x+1,y]); q.push([x-1,y]); q.push([x,y+1]); q.push([x,y-1]);
                }
            }
            ctx.putImageData(imageData, 0, 0);
        }

        // === IO and Project State ===
        function resetProjectState() {
            if (playing) playBtn.click();
            frames.forEach(f => { 
                layerOrder.forEach(layer => {
                    if (f[`${layer}Canvas`] && f[`${layer}Canvas`].parentElement) container.removeChild(f[`${layer}Canvas`]);
                });
            });
            frames = [];
            currentFrame = 0;
            audioClips = Array.from({ length: NUM_AUDIO_TRACKS }, () => []);
            renderAllAudioTimelines();
            deselectAllAudioClips();
            if (mode === 'cut' || mode === 'move') btnCut.click();
            clipboard = null; // Clear clipboard on reset
            updatePasteButtonState();
        }

        clearAllBtn.onclick = () => {
            showConfirm("Are you sure you want to clear everything? This cannot be undone.", () => {
                resetProjectState();
                addFrameBtn.click();
                updateTimeline();
                showNotification("Project cleared.", 2000);
            });
        };
        
        importImageBtn.onclick = () => imageLoader.click();

        imageLoader.onchange = (e) => {
            if (!e.target.files[0]) return;
            if (mode === 'move' && selectionImage) commitSelection();
            const reader = new FileReader();
            reader.onload = (event) => {
                const img = new Image();
                img.onload = () => {
                    const { canvas } = getActiveContextAndCanvas();
                    if (!canvas) return;
                    const hRatio=canvas.width/img.width, vRatio=canvas.height/img.height;
                    const ratio = Math.min(hRatio,vRatio) * 0.8; 
                    selectionImage=img;
                    selectionSize = {width:img.width*ratio, height:img.height*ratio};
                    selectionPos = {x:(canvas.width-selectionSize.width)/2, y:(canvas.height-selectionSize.height)/2};
                    selectionRotation=0; preFitState=null; isImportingImage=true; mode='move'; tool='brush';
                    updateToolUI();
                    toolSwitch.style.pointerEvents='none'; fillTool.style.pointerEvents='none';
                    selCanvas.style.pointerEvents='auto';
                    redrawSelection(); saveState();
                }
                img.src = event.target.result;
            }
            reader.readAsDataURL(e.target.files[0]);
            e.target.value = '';
        };
        
        saveProjectBtn.onclick = async () => {
            if(frames.length === 0) { showNotification("Nothing to save.", 3000); return; }
            if (selectionImage) commitSelection();
            
            showNotification("Saving project... this may take a moment.", 2000);

            await new Promise(resolve => setTimeout(resolve, 50));

            const projectData = {
                fps: fps,
                frames: frames.map(f => ({
                    bg: f.bgCanvas.toDataURL(),
                    draw: f.drawCanvas.toDataURL(),
                    fg: f.fgCanvas.toDataURL()
                })),
                audioClips: audioClips.map(track => track.map(clip => {
                    const clipData = { ...clip };
                    if (clip.buffer) {
                        clipData.buffer = audioBufferToWavBase64(clip.buffer);
                    }
                    return clipData;
                }))
            };

            const jsonString = JSON.stringify(projectData);
            const blob = new Blob([jsonString], {type: 'application/json'});
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = 'my-animation-project.json';
            a.click();
            URL.revokeObjectURL(a.href);
            showNotification("Project file saved!", 3000);
        };

        openProjectBtn.onclick = () => {
            showConfirm("Opening a project will replace the current one. Continue?", () => projectLoader.click());
        };
        
        projectLoader.onchange = (e) => {
            if (!e.target.files[0]) return;
            const reader = new FileReader();
            reader.onload = async (event) => {
                try {
                    resetProjectState();
                    const projectData = JSON.parse(event.target.result);
                    await loadProject(projectData);
                } catch(err) {
                    console.error("Error opening project file:", err);
                    showNotification("Error: Could not open invalid project file.", 5000);
                    resetProjectState();
                    addFrameBtn.click();
                } finally {
                    e.target.value = '';
                }
            };
            reader.readAsText(e.target.files[0]);
        };
        
        async function loadProject(projectData) {
            if (!projectData || !projectData.frames || !projectData.fps) {
                throw new Error("Invalid project file format.");
            }
            showNotification("Loading project...", 2000);
            fps = projectData.fps;
            fpsSelect.value = fps;
            frameDuration = 1000 / fps;
            const frameLoadPromises = projectData.frames.map(frameData => {
                return new Promise((resolve, reject) => {
                    const newCanvases = createLayeredCanvas();
                    const images = {};
                    let loadedCount = 0;
                    const checkDone = () => {
                        if(loadedCount === layerOrder.length) {
                            layerOrder.forEach(layer => newCanvases[`${layer}Ctx`].drawImage(images[layer], 0, 0));
                            resolve({ ...newCanvases, history:[], redo:[] });
                        }
                    };
                    layerOrder.forEach(layer => {
                        images[layer] = new Image();
                        images[layer].onload = () => { loadedCount++; checkDone(); };
                        images[layer].onerror = reject;
                        // Corrected base64 for a transparent 1x1 pixel PNG
                        images[layer].src = frameData[layer] || 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=';
                    });
                });
            });
            frames = await Promise.all(frameLoadPromises);
            
            // FIX: Restore audio clips from base64 data
            if (projectData.audioClips) {
                if (!audioContext) audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const audioLoadPromises = projectData.audioClips.map(trackData => {
                    return Promise.all(trackData.map(async clipData => {
                        if (clipData.buffer) {
                            try {
                                const buffer = await base64ToAudioBuffer(clipData.buffer, audioContext);
                                return { ...clipData, buffer: buffer };
                            } catch (err) {
                                console.error("Could not decode audio clip", err);
                                showNotification(`Failed to load audio clip: ${clipData.id}`, 4000);
                                return null; // Return null on failure
                            }
                        }
                        return clipData;
                    }));
                });
                audioClips = (await Promise.all(audioLoadPromises)).map(track => track.filter(Boolean)); // Filter out nulls
                renderAllAudioTimelines();
            }
            
            switchToFrame(0);
            saveState();
            updateTimeline();
            showNotification("Project loaded successfully!", 3000);
        }

        saveZipBtn.onclick = async () => {
            if(frames.length === 0) return;
            if (selectionImage) commitSelection();
            const zip = new JSZip();
            for (let i = 0; i < frames.length; i++) {
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = frames[i].bgCanvas.width; 
                tempCanvas.height = frames[i].bgCanvas.height;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.fillStyle = '#FFFFFF'; tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
                layerOrder.forEach(layer => tempCtx.drawImage(frames[i][`${layer}Canvas`], 0, 0));
                const dataUrl = tempCanvas.toDataURL('image/png', 1.0);
                const b64 = dataUrl.replace(/^data:image\/png;base64,/, '');
                zip.file(`frame-${String(i + 1).padStart(3, '0')}.png`, b64, { base64: true });
            }
            const blob = await zip.generateAsync({ type: 'blob' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = 'animation_frames.zip';
            a.click();
            URL.revokeObjectURL(a.href);
        };

        // Function to save frames as a ZIP with transparency
        saveTransparentZipBtn.onclick = async () => {
            if(frames.length === 0) { showNotification("Nothing to save.", 3000); return; }
            if (selectionImage) commitSelection();
            showNotification("Creating transparent ZIP...", 2000);
            const zip = new JSZip();
            for (let i = 0; i < frames.length; i++) {
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = frames[i].bgCanvas.width; 
                tempCanvas.height = frames[i].bgCanvas.height;
                const tempCtx = tempCanvas.getContext('2d');
                // KEY DIFFERENCE: Do not fill the background, preserving transparency
                layerOrder.forEach(layer => tempCtx.drawImage(frames[i][`${layer}Canvas`], 0, 0));
                const dataUrl = tempCanvas.toDataURL('image/png', 1.0);
                const b64 = dataUrl.replace(/^data:image\/png;base64,/, '');
                zip.file(`frame-${String(i + 1).padStart(3, '0')}.png`, b64, { base64: true });
            }
            const blob = await zip.generateAsync({ type: 'blob' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = 'animation_frames_transparent.zip';
            a.click();
            URL.revokeObjectURL(a.href);
            showNotification("Transparent ZIP saved!", 3000);
        };
        
        // === Selection / Cut & Paste Logic ===
        const selCanvas = document.createElement('canvas');
        const selCtx = selCanvas.getContext('2d');
        container.appendChild(selCanvas);
        selCanvas.style.position='absolute'; selCanvas.style.top='0'; selCanvas.style.left='0';
        selCanvas.style.pointerEvents = 'none';

        function resizeCanvases() {
            const w = container.clientWidth;
            const h = container.clientHeight;

            // Ensure dimensions are at least 1 to prevent errors
            const newCanvasWidth = Math.max(1, w);
            const newCanvasHeight = Math.max(1, h);

            frames.forEach(f => {
                const tempImgs = {};
                // Capture original dimensions before resizing the canvas itself
                const oldCanvasWidth = f.bgCanvas.width; 
                const oldCanvasHeight = f.bgCanvas.height;

                layerOrder.forEach(layer => {
                    tempImgs[layer] = new Image();
                    tempImgs[layer].src = f[`${layer}Canvas`].toDataURL(); // Capture current content at old resolution

                    // Resize the actual canvas elements
                    f[`${layer}Canvas`].width = newCanvasWidth; 
                    f[`${layer}Canvas`].height = newCanvasHeight;

                    // When the image loads, draw it scaled onto the newly resized canvas
                    tempImgs[layer].onload = () => {
                        f[`${layer}Ctx`].drawImage(tempImgs[layer], 0, 0, oldCanvasWidth, oldCanvasHeight, 0, 0, newCanvasWidth, newCanvasHeight);
                    };
                    // Handle potential synchronous load or cached images
                    if (tempImgs[layer].complete) {
                        tempImgs[layer].onload(); // Manually call if already loaded
                    }
                });
            });
            selCanvas.width = newCanvasWidth;
            selCanvas.height = newCanvasHeight;
            redrawSelection();
            if (frames.length > 0) {
                // No need to saveState here, as it's a visual resize, not a content change for undo/redo
                if (frames[currentFrame]) switchToFrame(currentFrame);
            }
        }
        window.addEventListener('resize', resizeCanvases);

        btnCut.onclick = () => {
            if (!frames[currentFrame]) return;
            if (mode === 'cut' || mode === 'move') {
                if (selectionImage) { commitSelection(); }
                mode = 'brush'; tool = 'brush'; selectionImage = null; selectionPath = []; isImportingImage = false;
                clipboard = null; // Clear clipboard on deselect
                selCtx.clearRect(0, 0, selCanvas.width, selCanvas.height);
                toolSwitch.style.pointerEvents = 'auto'; fillTool.style.pointerEvents = 'auto';
                selCanvas.style.pointerEvents = 'none';
                updateTimeline();
            } else {
                mode = 'cut'; tool = 'brush';
                toolSwitch.style.pointerEvents = 'none'; fillTool.style.pointerEvents = 'none';
                selCanvas.style.pointerEvents = 'auto';
            }
            updateToolUI(); 
            redrawSelection(); // Hide/show buttons
            saveState();
        };
        
        function updatePasteButtonState() {
            pasteSelectionBtn.style.display = clipboard ? 'block' : 'none';
            // Also update flip buttons visibility based on selectionImage
            flipHorizontalBtn.style.display = selectionImage ? 'block' : 'none';
            flipVerticalBtn.style.display = selectionImage ? 'block' : 'none';
        }
        
        copySelectionBtn.onclick = (e) => {
            e.stopPropagation();
            copySelection();
        };

        pasteSelectionBtn.onclick = (e) => {
            e.stopPropagation();
            pasteSelection();
        };

        // Added click listeners for the flip buttons
        flipHorizontalBtn.onclick = (e) => {
            e.stopPropagation();
            flipSelectionHorizontal();
        };

        flipVerticalBtn.onclick = (e) => {
            e.stopPropagation();
            flipSelectionVertical();
        };

        function copySelection() {
            if (!selectionImage) return;

            // 1. Stamp the current selection onto the canvas
            commitSelection();

            // 2. The current selection becomes the "copy" that the user moves.
            // We just need to save its state to the clipboard.
            clipboard = {
                image: selectionImage,
                size: { ...selectionSize },
                rotation: selectionRotation
            };

            showNotification('Original stamped! Moving the copy.', 2000);
            updatePasteButtonState(); // Make paste button visible
            updateTimeline();
            saveState();
        }

        function pasteSelection() {
            if (!clipboard) return;
            
            // Stamp the currently active selection (if any)
            if (selectionImage) {
                commitSelection();
            }

            // Create a new selection from the clipboard
            selectionImage = clipboard.image;
            selectionSize = { ...clipboard.size };
            selectionRotation = clipboard.rotation;

            // Position the new pasted item exactly where the original was copied
            selectionPos = { x: (selCanvas.width - selectionSize.width) / 2, y: (selCanvas.height - selectionSize.height) / 2 };
            
            mode = 'move';
            preFitState = null;
            isImportingImage = false;

            selCanvas.style.pointerEvents = 'auto';
            updateToolUI();
            redrawSelection();
            saveState();
        }

        // NEW: Function to flip the selection image horizontally
        function flipSelectionHorizontal() {
            if (!selectionImage) return;

            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = selectionImage.width;
            tempCanvas.height = selectionImage.height;
            const tempCtx = tempCanvas.getContext('2d');

            tempCtx.translate(tempCanvas.width, 0);
            tempCtx.scale(-1, 1);
            tempCtx.drawImage(selectionImage, 0, 0);

            selectionImage = new Image();
            selectionImage.onload = () => {
                redrawSelection();
                saveState();
            };
            selectionImage.src = tempCanvas.toDataURL();
            showNotification('Flipped Horizontal!', 1000);
        }

        // NEW: Function to flip the selection image vertically
        function flipSelectionVertical() {
            if (!selectionImage) return;

            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = selectionImage.width;
            tempCanvas.height = selectionImage.height;
            const tempCtx = tempCanvas.getContext('2d');

            tempCtx.translate(0, tempCanvas.height);
            tempCtx.scale(1, -1);
            tempCtx.drawImage(selectionImage, 0, 0);

            selectionImage = new Image();
            selectionImage.onload = () => {
                redrawSelection();
                saveState();
            };
            selectionImage.src = tempCanvas.toDataURL();
            showNotification('Flipped Vertical!', 1000);
        }

        fitToCanvasBtn.onclick = (e) => {
            e.stopPropagation(); // Prevent click from bubbling to document listener
            if (!selectionImage) return;
            const { canvas } = getActiveContextAndCanvas();
            if (!canvas) return;
            if (preFitState === null) {
                preFitState = { pos: { ...selectionPos }, size: { ...selectionSize }, rotation: selectionRotation };
                const ratio = Math.min(canvas.width / selectionImage.width, canvas.height / selectionImage.height);
                selectionSize = { width: selectionImage.width * ratio, height: selectionImage.height * ratio };
                selectionPos = { x: (canvas.width - selectionSize.width) / 2, y: (canvas.height - selectionSize.height) / 2 };
                selectionRotation = 0; // Fitting to canvas resets rotation
                fitToCanvasBtn.innerText = 'Reset';
            } else {
                selectionPos = preFitState.pos; 
                selectionSize = preFitState.size;
                selectionRotation = preFitState.rotation;
                preFitState = null; 
                fitToCanvasBtn.innerText = 'Fit';
            }
            redrawSelection(); 
            saveState();
        };

        // MODIFIED: This function now shows/hides the #selection-controls container
        // instead of positioning individual buttons.
        function redrawSelection(){
            if (!selCtx || !selCanvas) return;
            selCtx.clearRect(0, 0, selCanvas.width, selCanvas.height);
            
            // Hide the container by default
            selectionControls.style.display = 'none';

            if (selectionPath.length >= 2 && mode === 'cut' && !selectionImage) {
                selCtx.strokeStyle = 'rgba(0,100,255,0.7)'; selCtx.lineWidth = 2; selCtx.setLineDash([5, 5]);
                selCtx.beginPath(); selCtx.moveTo(selectionPath[0].x, selectionPath[0].y);
                for (let i = 1; i < selectionPath.length; i++) selCtx.lineTo(selectionPath[i].x, selectionPath[i].y);
                selCtx.stroke(); selCtx.setLineDash([]);
            }
            
            if (selectionImage && mode === 'move') {
                const centerX = selectionPos.x + selectionSize.width / 2;
                const centerY = selectionPos.y + selectionSize.height / 2;

                selCtx.save();
                selCtx.translate(centerX, centerY);
                selCtx.rotate(selectionRotation);
                
                selCtx.drawImage(selectionImage, -selectionSize.width / 2, -selectionSize.height / 2, selectionSize.width, selectionSize.height);
                
                selCtx.strokeStyle = 'rgba(0,100,255,0.9)'; selCtx.lineWidth = 1; selCtx.setLineDash([3, 3]);
                selCtx.strokeRect(-selectionSize.width / 2, -selectionSize.height / 2, selectionSize.width, selectionSize.height);
                selCtx.setLineDash([]);
                
                const halfW = selectionSize.width / 2;
                const halfH = selectionSize.height / 2;
                
                // MODIFIED: Draw resize handles on midpoints
                drawResizeHandle(0, -halfH); // n
                drawResizeHandle(0,  halfH); // s
                drawResizeHandle(-halfW, 0); // w
                drawResizeHandle( halfW, 0); // e

                // MODIFIED: Draw rotation handles at corners, offset
                const rotationHandleOffset = ROTATE_HANDLE_DIST / Math.sqrt(2);
                drawRotateHandle(-halfW - rotationHandleOffset, -halfH - rotationHandleOffset); // nw
                drawRotateHandle( halfW + rotationHandleOffset, -halfH - rotationHandleOffset); // ne
                drawRotateHandle(-halfW - rotationHandleOffset,  halfH + rotationHandleOffset); // sw
                drawRotateHandle( halfW + rotationHandleOffset,  halfH + rotationHandleOffset); // se
                
                selCtx.restore();
                
                // MODIFICATION: Show the button container
                selectionControls.style.display = 'flex';
                
                // Update paste button visibility within the container
                updatePasteButtonState(); 
            }
        }

        // Draws a square resize handle at a given local coordinate
        function drawResizeHandle(x, y) {
            selCtx.save();
            // No translation or rotation needed as they are drawn in local space already
            selCtx.fillStyle = 'rgba(0,100,255,0.8)'; // Blue for resizing
            selCtx.fillRect(x - HANDLE_SIZE / 2, y - HANDLE_SIZE / 2, HANDLE_SIZE, HANDLE_SIZE);
            selCtx.restore();
        }

        // Draws a circular rotation handle at a given local coordinate
        function drawRotateHandle(x, y) {
            selCtx.save();
            // No translation or rotation needed
            selCtx.fillStyle = 'rgba(255,100,0,0.8)'; // Orange for rotating
            selCtx.beginPath();
            selCtx.arc(x, y, ROTATE_HANDLE_RADIUS, 0, Math.PI * 2);
            selCtx.fill();
            selCtx.restore();
        }

        function getResizeHandleUnderPoint(mouseX, mouseY) {
            if(!selectionImage || mode !== 'move') return null;
            const cx = selectionPos.x + selectionSize.width / 2;
            const cy = selectionPos.y + selectionSize.height / 2;
            // Transform mouse point to local, unrotated coordinates of the selection box
            const localMouse = rotatePoint(mouseX - cx, mouseY - cy, -selectionRotation);
            
            const halfW = selectionSize.width / 2;
            const halfH = selectionSize.height / 2;
            
            // Define handle positions in local coordinates
            const handles = {
                n: { x: 0, y: -halfH },
                s: { x: 0, y: halfH },
                w: { x: -halfW, y: 0 },
                e: { x: halfW, y: 0 }
            };
            
            // Check if the local mouse position is within the bounds of any handle
            for (const dir in handles) {
                const hx = handles[dir].x;
                const hy = handles[dir].y;
                if (Math.abs(localMouse.x - hx) <= HANDLE_SIZE / 2 && Math.abs(localMouse.y - hy) <= HANDLE_SIZE / 2) {
                    return dir;
                }
            }
            return null;
        }
        
        function rotatePoint(x, y, angle) {
            return {
                x: x * Math.cos(angle) - y * Math.sin(angle),
                y: x * Math.sin(angle) + y * Math.cos(angle)
            };
        }

        function getRotateHandleUnderPoint(mouseX, mouseY){
            if(!selectionImage || mode !== 'move') return null;
            const cx = selectionPos.x + selectionSize.width / 2;
            const cy = selectionPos.y + selectionSize.height / 2;
            // Transform mouse to local, unrotated coordinates
            const localMouse = rotatePoint(mouseX - cx, mouseY - cy, -selectionRotation);
            
            const halfW = selectionSize.width / 2;
            const halfH = selectionSize.height / 2;
            const rotationHandleOffset = ROTATE_HANDLE_DIST / Math.sqrt(2);

            // Define handle positions in local coordinates, including the offset
            const handles = {
                nw: { x: -halfW - rotationHandleOffset, y: -halfH - rotationHandleOffset },
                ne: { x:  halfW + rotationHandleOffset, y: -halfH - rotationHandleOffset },
                sw: { x: -halfW - rotationHandleOffset, y:  halfH + rotationHandleOffset },
                se: { x:  halfW + rotationHandleOffset, y:  halfH + rotationHandleOffset }
            };

            for(const dir in handles){
                // Check distance from local mouse point to the center of the rotation handle
                if (Math.hypot(localMouse.x - handles[dir].x, localMouse.y - handles[dir].y) < ROTATE_HANDLE_RADIUS + 5) { // Add some buffer
                    return dir;
                }
            }
            return null;
        }

        function pointInRotatedRect(px, py, rx, ry, rw, rh, rotation){
            // Modified to handle cases where rw or rh might be zero, preventing division by zero.
            if (rw === 0 || rh === 0) {
                // If width or height is zero, consider it not in the rectangle
                return false;
            }
            const cx=rx+rw/2, cy=ry+rh/2; const dx=px-cx, dy=py-cy;
            const cos=Math.cos(-rotation), sin=Math.sin(-rotation);
            const localX = dx*cos - dy*sin;
            const localY = dx*sin + dy*cos;
            return Math.abs(localX)<=rw/2 && Math.abs(localY)<=rh/2;
        }

        function processSelection(){
            if (selectionPath.length < 3 || !frames[currentFrame]) { btnCut.click(); return; }
            const { ctx, canvas } = getActiveContextAndCanvas();
            if (!ctx || !canvas) { btnCut.click(); return; }
            const xs=selectionPath.map(p=>p.x), ys=selectionPath.map(p=>p.y);
            const minX=Math.min(...xs), maxX=Math.max(...xs), minY=Math.min(...ys), maxY=Math.max(...ys);
            const width=Math.max(1,maxX-minX), height=Math.max(1,maxY-minY);
            selectionBBox={x:minX,y:minY,width,height}; selectionPos={x:minX,y:minY};
            selectionSize={width,height}; selectionRotation=0;
            const tempCanvas = document.createElement('canvas'); tempCanvas.width=width; tempCanvas.height=height;
            const tempCtx=tempCanvas.getContext('2d');
            tempCtx.save(); tempCtx.beginPath();
            tempCtx.moveTo(selectionPath[0].x-minX, selectionPath[0].y-minY);
            for(let i=1; i<selectionPath.length; i++) tempCtx.lineTo(selectionPath[i].x-minX, selectionPath[i].y-minY);
            tempCtx.closePath(); tempCtx.clip();
            tempCtx.drawImage(canvas, -minX, -minY);
            tempCtx.restore();
            selectionImage=new Image();
            selectionImage.onload = () => {
                ctx.save(); ctx.beginPath();
                for(let i=0; i<selectionPath.length; i++) ctx.lineTo(selectionPath[i].x, selectionPath[i].y);
                ctx.closePath(); ctx.globalCompositeOperation='destination-out'; ctx.fill();
                ctx.restore();
                mode='move';
                redrawSelection(); saveState(); updateTimeline();
            };
            selectionImage.onerror = () => { console.error("Error loading selection image"); btnCut.click(); }
            if (tempCanvas.width > 0 && tempCanvas.height > 0) selectionImage.src=tempCanvas.toDataURL();
            else { console.warn("Skipping selection due to zero-size canvas. Defaulting to empty selection."); btnCut.click(); selectionImage = null; } // Ensure selectionImage is null on error
        }

        function commitSelection() {
            if (!selectionImage || !frames[currentFrame]) return;
            const {ctx: targetCtx} = getActiveContextAndCanvas();
            if (!targetCtx) return;
            targetCtx.save();
            targetCtx.translate(selectionPos.x + selectionSize.width/2, selectionPos.y + selectionSize.height/2);
            targetCtx.rotate(selectionRotation);
            targetCtx.drawImage(selectionImage, -selectionSize.width/2, -selectionSize.height/2, selectionSize.width, selectionSize.height);
            targetCtx.restore();
            if (isImportingImage) isImportingImage = false;
        }
        
        // === Audio Functions ===
        function setupAudioUI() {
            for (let i = 0; i < NUM_AUDIO_TRACKS; i++) {
                // Create track controls
                const controlDiv = document.createElement('div');
                controlDiv.className = 'audio-track-controls';
                controlDiv.dataset.trackIndex = i;
                controlDiv.innerHTML = `<span>Audio ${i + 1}</span>`;
                timelineControls.appendChild(controlDiv);
                controlDiv.onclick = () => setActiveAudioTrack(i);

                // Create timeline containers
                const timelineContainer = document.createElement('div');
                timelineContainer.className = 'audio-timeline-container';
                timelineContainer.innerHTML = `<div class="audio-track" data-track-index="${i}"></div>`;
                audioTimelinesContainer.insertBefore(timelineContainer, frameMarkersContainer);
            }
            deleteAudioBtn.onclick = deleteSelectedAudioClip;
            setActiveAudioTrack(0);
        }

        function setActiveAudioTrack(index) {
            activeAudioTrack = index;
            document.querySelectorAll('.audio-track-controls').forEach((div, i) => {
                div.classList.toggle('active', i === index);
            });
        }

        importAudioBtn.onclick = () => {
            if (!audioContext) {
                try { audioContext = new (window.AudioContext || window.webkitAudioContext)(); } 
                catch (e) { showNotification("Web Audio API is not supported.", 5000); return; }
            }
            audioLoader.click();
        };

        audioLoader.onchange = (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (event) => {
            audioContext.decodeAudioData(event.target.result)
                .then(buffer => {
                    const newClip = {
                        id: `clip_${Date.now()}`,
                        buffer: buffer,
                        timelineStart: 0,
                        clipStart: 0,
                        clipDuration: buffer.duration,
                        color: `hsl(${Math.random() * 360}, 50%, 70%)`,
                        trackIndex: activeAudioTrack
                    };
                    audioClips[activeAudioTrack].push(newClip);
                    renderAllAudioTimelines();
                })
                .catch(err => { console.error("Error decoding audio:", err); showNotification("Failed to decode audio file.", 4000); });
            };
            reader.readAsArrayBuffer(file);
            e.target.value = '';
        };

        function renderAllAudioTimelines() {
            document.querySelectorAll('.audio-track').forEach((trackDiv, index) => {
                renderAudioTrack(trackDiv, audioClips[index]);
            });
        }

        function renderAudioTrack(trackContainer, clips) {
            trackContainer.innerHTML = '';
            clips.forEach(clip => {
                const clipEl = document.createElement('div');
                clipEl.className = 'audio-clip';
                clipEl.id = clip.id;
                clipEl.style.left = `${timeToPx(clip.timelineStart)}px`;
                clipEl.style.width = `${timeToPx(clip.clipDuration)}px`;
                clipEl.style.backgroundColor = clip.color;
                if (selectedAudioClip && selectedAudioClip.id === clip.id) {
                    clipEl.classList.add('selected');
                }
                const waveformEl = document.createElement('canvas');
                waveformEl.className = 'audio-clip-waveform';
                clipEl.appendChild(waveformEl);
                const leftHandle = document.createElement('div');
                leftHandle.className = 'resize-handle left';
                clipEl.appendChild(leftHandle);
                const rightHandle = document.createElement('div');
                rightHandle.className = 'resize-handle right';
                clipEl.appendChild(rightHandle);
                trackContainer.appendChild(clipEl);
                setTimeout(() => drawClipWaveform(clip, waveformEl), 0);
                addClipEventListeners(clipEl, clip);
            });
        }

        function drawClipWaveform(clip, canvas) {
            const { buffer, clipStart, clipDuration } = clip;
            if (!buffer) return;
            const { width, height } = canvas.parentElement.getBoundingClientRect();
            if (!width || !height) {
                console.warn("Waveform not drawn because element has no dimensions yet.");
                return;
            }
            canvas.width = width; canvas.height = height;
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, width, height);
            const channelData = buffer.getChannelData(0);
            const startSample = Math.floor(clipStart * buffer.sampleRate);
            const endSample = Math.floor((clipStart + clipDuration) * buffer.sampleRate);
            const totalVisibleSamples = endSample - startSample;
            if (totalVisibleSamples <= 0) return;
            ctx.lineWidth = 1; ctx.strokeStyle = 'rgba(255, 255, 255, 0.75)'; ctx.beginPath();
            const halfHeight = height / 2;
            const samplesPerPixel = totalVisibleSamples / width;
            for (let i = 0; i < width; i++) {
                const chunkStart = startSample + Math.floor(i * samplesPerPixel);
                const chunkEnd = startSample + Math.floor((i + 1) * samplesPerPixel);
                let min = 1.0, max = -1.0;
                for (let j = chunkStart; j < chunkEnd; j++) {
                    const sample = channelData[j];
                    if (sample < min) min = sample;
                    if (sample > max) max = sample;
                }
                ctx.moveTo(i, halfHeight + (min * halfHeight));
                ctx.lineTo(i, halfHeight + (max * halfHeight));
            }
            ctx.stroke();
        }
        
        function drawFrameMarkers() {
            const container = audioTimelinesContainer.querySelector('#frame-markers');
            container.innerHTML = '';
            let totalWidth = 0;
            for (let i = 0; i < frames.length; i++) {
                const marker = document.createElement('div');
                marker.className = 'frame-marker';
                marker.style.left = `${totalWidth}px`;
                container.appendChild(marker);
                totalWidth += FRAME_WIDTH_PX;
            }
            timelineWrapper.style.minWidth = `${totalWidth}px`;
        }

        function selectAudioClip(clipId, trackIndex) {
            if (selectedAudioClip && selectedAudioClip.id === clipId) return;
            deselectAllAudioClips();
            selectedAudioClip = { id: clipId, trackIndex };
            const clipEl = document.getElementById(clipId);
            if (clipEl) clipEl.classList.add('selected');
            deleteAudioBtn.style.display = 'block';
        }

        function deselectAllAudioClips() {
            if (selectedAudioClip) {
                const prevSelected = document.getElementById(selectedAudioClip.id);
                if (prevSelected) prevSelected.classList.remove('selected');
            }
            selectedAudioClip = null;
            if (deleteAudioBtn) deleteAudioBtn.style.display = 'none';
        }

        function deleteSelectedAudioClip() {
            if (!selectedAudioClip) return;
            showConfirm("Are you sure you want to delete this audio clip?", () => {
                const { id, trackIndex } = selectedAudioClip;
                audioClips[trackIndex] = audioClips[trackIndex].filter(c => c.id !== id);
                deselectAllAudioClips();
                renderAllAudioTimelines();
            });
        }

        document.querySelectorAll('.audio-timeline-container').forEach(container => {
            container.addEventListener('click', (e) => {
                if (e.target.classList.contains('audio-timeline-container') || e.target.classList.contains('audio-track')) {
                    deselectAllAudioClips();
                }
            });
        });

        function addClipEventListeners(clipEl, clip) {
            clipEl.addEventListener('pointerdown', e => {
                e.stopPropagation();
                selectAudioClip(clip.id, clip.trackIndex);
                if (e.target.classList.contains('resize-handle')) {
                    initResize(e, clip, e.target.classList.contains('left'));
                } else {
                    initDrag(e, clip);
                }
            });
        }

        function initDrag(e, clip) {
            e.stopPropagation();
            dragInfo = {
                type: 'drag', clip, element: e.target.closest('.audio-clip'),
                startX: e.clientX, initialLeft: e.target.closest('.audio-clip').offsetLeft
            };
            document.addEventListener('pointermove', handlePointerMove);
            document.addEventListener('pointerup', handlePointerUp);
        }

        function initResize(e, clip, isLeftHandle) {
            e.stopPropagation();
            dragInfo = {
                type: 'resize', clip, element: e.target.parentElement,
                isLeft: isLeftHandle, startX: e.clientX,
                initialLeft: e.target.parentElement.offsetLeft,
                initialWidth: e.target.parentElement.offsetWidth,
                initialTimelineStart: clip.timelineStart,
                initialClipStart: clip.clipStart,
                initialClipDuration: clip.clipDuration
            };
            document.addEventListener('pointermove', handlePointerMove);
            document.addEventListener('pointerup', handlePointerUp);
        }

        function handlePointerMove(e) {
            if (!dragInfo.type) return;
            e.preventDefault();
            const { clip, element, startX } = dragInfo;
            const dx = e.clientX - startX;
            if (dragInfo.type === 'drag') {
                const { initialLeft } = dragInfo;
                const newLeft = Math.max(0, initialLeft + dx);
                element.style.left = `${newLeft}px`;
                clip.timelineStart = pxToTime(newLeft);
            } else if (dragInfo.type === 'resize') {
                const { isLeft, initialWidth } = dragInfo;
                if (isLeft) {
                    const deltaTime = pxToTime(dx);
                    const newBufferClipStart = dragInfo.initialClipStart + deltaTime;
                    const newBufferClipDuration = dragInfo.initialClipDuration - deltaTime;
                    if (newBufferClipStart >= 0 && newBufferClipDuration >= 0.1 && newBufferClipStart < clip.buffer.duration) {
                        clip.timelineStart = dragInfo.initialTimelineStart + deltaTime;
                        clip.clipStart = newBufferClipStart;
                        clip.clipDuration = newBufferClipDuration;
                        element.style.left = `${timeToPx(clip.timelineStart)}px`;
                        element.style.width = `${timeToPx(clip.clipDuration)}px`;
                        requestAnimationFrame(() => drawClipWaveform(clip, element.querySelector('canvas')));
                    }
                } else { // Right handle
                    const newWidth = Math.max(20, initialWidth + dx);
                    const newDuration = pxToTime(newWidth);
                    if (clip.clipStart + newDuration <= clip.buffer.duration) {
                        element.style.width = `${newWidth}px`;
                        clip.clipDuration = newDuration;
                        requestAnimationFrame(() => drawClipWaveform(clip, element.querySelector('canvas')));
                    }
                }
            }
        }
        
        function handlePointerUp() {
            if(dragInfo.type === 'resize' || dragInfo.type === 'drag') {
                renderAllAudioTimelines();
            }
            dragInfo = {};
            document.removeEventListener('pointermove', handlePointerMove);
            document.removeEventListener('pointerup', handlePointerUp);
        }

        // === Global Event Listeners ===
        document.addEventListener('pointerdown', e => {
            // MODIFIED: Ignore clicks on the new selection controls container
            if (e.target.closest('.tools, .sidebar, #timeline-section, #selection-controls')) return;
            const { canvas } = getActiveContextAndCanvas();
            if (!canvas) return;
            const rect = selCanvas.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            const x = clientX - rect.left; const y = clientY - rect.top;
            if(mode === 'brush'){
                const brushRect = canvas.getBoundingClientRect();
                const brushX = Math.floor(clientX - brushRect.left);
                const brushY = Math.floor(clientY - brushRect.top);
                if(tool === 'fill'){ floodFill(brushX, brushY, colorInput.value); return; }
                saveState(); drawing = true; hasDrawn = false; lastX = null; lastY = null; draw(e);
                return;
            }
            if(mode === 'cut'){
                isSelecting = true; selectionPath = [{x, y}];
                redrawSelection(); return;
            }
            if(mode === 'move'){
                const rotHandle = getRotateHandleUnderPoint(x, y);
                if (rotHandle) {
                    rotating = true;
                    const centerX = selectionPos.x + selectionSize.width / 2;
                    const centerY = selectionPos.y + selectionSize.height / 2;
                    rotationStartAngle = Math.atan2(y - centerY, x - centerX) - selectionRotation;
                    return;
                }

                const resHandle = getResizeHandleUnderPoint(x, y);
                if(resHandle){
                    resizing = true;
                    resizeDir = resHandle;
                    dragOffset.originalX = selectionPos.x;
                    dragOffset.originalY = selectionPos.y;
                    dragOffset.originalWidth = selectionSize.width;
                    dragOffset.originalHeight = selectionSize.height;
                    dragOffset.originalRotation = selectionRotation;
                    dragOffset.x = x;
                    dragOffset.y = y;
                    return;
                }
                if(pointInRotatedRect(x,y,selectionPos.x,selectionPos.y,selectionSize.width,selectionSize.height,selectionRotation)){
                    dragging=true; dragOffset.x=x-selectionPos.x; dragOffset.y=y-selectionPos.y;
                } else { btnCut.click(); }
            }
        });

        document.addEventListener('pointermove', e => {
            if (dragInfo.type) return; // Prevent canvas interaction while dragging audio
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            if (mode === 'brush' && drawing && frames[currentFrame]) { draw(e); return; }
            const selRect = selCanvas.getBoundingClientRect();
            const x = clientX - selRect.left; const y = clientY - selRect.top;
            if(mode === 'cut'){
                if(!isSelecting) return;
                selectionPath.push({x, y}); redrawSelection(); return;
            }
            
            if(mode === 'move'){
                if(dragging){
                    e.preventDefault(); selectionPos.x = x-dragOffset.x; selectionPos.y=y-dragOffset.y; redrawSelection();
                } else if (rotating) {
                    e.preventDefault();
                    const centerX = selectionPos.x + selectionSize.width / 2;
                    const centerY = selectionPos.y + selectionSize.height / 2;
                    const angle = Math.atan2(y - centerY, x - centerX);
                    selectionRotation = angle - rotationStartAngle;
                    redrawSelection();
                } else if (resizing) {
                    e.preventDefault();
                    const dx = x - dragOffset.x;
                    const dy = y - dragOffset.y;

                    // Convert mouse delta to the selection's local (unrotated) coordinate system
                    const localDx = dx * Math.cos(-selectionRotation) - dy * Math.sin(-selectionRotation);
                    const localDy = dx * Math.sin(-selectionRotation) + dy * Math.cos(-selectionRotation);

                    let widthChange = 0;
                    let heightChange = 0;

                    // Determine how much width and height should change based on the handle being dragged
                    if (resizeDir.includes('e')) { widthChange = localDx; }
                    if (resizeDir.includes('w')) { widthChange = -localDx; }
                    if (resizeDir.includes('s')) { heightChange = localDy; }
                    if (resizeDir.includes('n')) { heightChange = -localDy; }

                    const newWidth = Math.max(20, dragOffset.originalWidth + widthChange);
                    const newHeight = Math.max(20, dragOffset.originalHeight + heightChange);

                    const dw = newWidth - dragOffset.originalWidth;
                    const dh = newHeight - dragOffset.originalHeight;

                    selectionSize.width = newWidth;
                    selectionSize.height = newHeight;
                    
                    let centerDx = 0;
                    let centerDy = 0;
                    
                    // Calculate how the center point should shift in local coordinates
                    if (resizeDir.includes('e')) centerDx = dw / 2;
                    if (resizeDir.includes('w')) centerDx = -dw / 2;
                    if (resizeDir.includes('s')) centerDy = dh / 2;
                    if (resizeDir.includes('n')) centerDy = -dh / 2;
                    
                    // Rotate the center point shift back to global coordinates
                    const globalCenterDx = centerDx * Math.cos(selectionRotation) - centerDy * Math.sin(selectionRotation);
                    const globalCenterDy = centerDx * Math.sin(selectionRotation) + centerDy * Math.cos(selectionRotation);
                    
                    // Apply the new position based on the original position and the calculated shift
                    selectionPos.x = dragOffset.originalX + globalCenterDx;
                    selectionPos.y = dragOffset.originalY + globalCenterDy;
                    
                    redrawSelection();
                }
            }
        });

        document.addEventListener('pointerup', e => {
            if(mode === 'brush'){
                if(drawing && hasDrawn) { saveState(); updateTimeline(); }
                drawing = false; lastX = null; lastY = null; hasDrawn = false; return;
            }
            if(mode === 'cut'){
                if(!isSelecting) return;
                isSelecting = false;
                if(selectionPath.length < 10){
                    selectionPath = []; redrawSelection(); btnCut.click(); return;
                }
                selectionPath.push(selectionPath[0]); processSelection(); return;
            }
            if (mode === 'move') {
                if (dragging || resizing || rotating) { 
                    dragging=resizing=rotating=false; preFitState=null;
                    fitToCanvasBtn.innerText = 'Fit';
                    saveState();
                }
            }
        });

        const snapPoints = [1, 5, 10, 15, 25, 50, 75, 100];
        const snapThreshold = 2;
        sizeInput.addEventListener('input', () => {
            let currentValue = parseInt(sizeInput.value);
            for (const point of snapPoints) {
                if (Math.abs(currentValue - point) <= snapThreshold) {
                    if (currentValue !== point) sizeInput.value = point;
                    break;
                }
            }
        });

        opacitySlider.addEventListener('input', () => {
            if (frames[currentFrame]) switchToFrame(currentFrame);
        });
        
        document.addEventListener('keydown', (e) => {
            if (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'SELECT') return;
            if (e.ctrlKey || e.metaKey) {
                if (e.key === 'z') { e.preventDefault(); undoBtn.click(); }
                else if (e.key === 'y') { e.preventDefault(); redoBtn.click(); }
                else if (e.key.toLowerCase() === 'c' && mode === 'move') { e.preventDefault(); copySelection(); }
                else if (e.key.toLowerCase() === 'v') { e.preventDefault(); pasteSelection(); }

            } else if (e.key === 'Escape') {
                if (mode === 'cut' || mode === 'move') btnCut.click();
            } else if (e.key.toLowerCase() === 's') { // Atalho para modo de sele√ß√£o/movimento
                e.preventDefault();
                // Se estiver no modo de pincel, muda para o modo de corte (sele√ß√£o inicial)
                if (mode === 'brush') {
                    mode = 'cut';
                    tool = 'brush'; // Reseta a ferramenta para pincel no modo de corte
                    toolSwitch.style.pointerEvents = 'none';
                    fillTool.style.pointerEvents = 'none';
                    selCanvas.style.pointerEvents = 'auto';
                    updateToolUI(); // Atualiza a UI para o modo 'cut'
                    redrawSelection();
                    saveState();
                } 
                // Se j√° estiver no modo 'cut' e houver uma sele√ß√£o (imagem), muda para o modo 'move'
                // O btnCut.click() j√° faz isso de forma eficaz, mas aqui garantimos o "move" explicitamente
                else if (mode === 'cut' && selectionImage) {
                    mode = 'move';
                    updateToolUI(); // Atualiza a UI para o modo 'move'
                    redrawSelection();
                    saveState();
                }
            }
        });
        
        timeline.addEventListener('dragstart', (e) => {
            if(e.target.tagName === 'IMG') {
                draggedIndex = parseInt(e.target.dataset.index);
                setTimeout(() => { e.target.classList.add('dragging'); }, 0);
            }
        });
        timeline.addEventListener('dragend', (e) => {
            if(e.target.tagName === 'IMG') e.target.classList.remove('dragging');
            draggedIndex = null;
        });
        timeline.addEventListener('dragover', (e) => e.preventDefault());
        timeline.addEventListener('drop', (e) => {
            e.preventDefault();
            if(e.target.tagName === 'IMG' && draggedIndex !== null) {
                const targetIndex = parseInt(e.target.dataset.index);
                e.target.classList.remove('dragging');
                if(draggedIndex !== targetIndex) {
                    const [draggedFrame] = frames.splice(draggedIndex, 1);
                    frames.splice(targetIndex, 0, draggedFrame);
                    switchToFrame(targetIndex);
                }
            }
        });
        
        // === Audio Buffer Conversion Functions ===
        function audioBufferToWavBase64(buffer) {
            const numOfChan = buffer.numberOfChannels;
            const length = buffer.length * numOfChan * 2 + 44;
            const buffer_ = new ArrayBuffer(length);
            const view = new DataView(buffer_);
            const channels = [];
            let i, sample;
            let offset = 0;
            let pos = 0;

            // Header
            setUint32(0x46464952); // "RIFF"
            setUint32(length - 8); // file length - 8
            setUint32(0x45564157); // "WAVE"
            setUint32(0x20746d66); // "fmt " chunk
            setUint32(16); // length of fmt data
            setUint16(1); // PCM - integer samples
            setUint16(numOfChan); // two channels
            setUint32(buffer.sampleRate); // sample rate
            setUint32(buffer.sampleRate * 2 * numOfChan); // byte rate
            setUint16(numOfChan * 2); // block align
            setUint16(16); // bits per sample
            setUint32(0x61746164); // "data" - chunk
            setUint32(length - pos - 4); // data length

            function setUint16(data) {
                view.setUint16(pos, data, true);
                pos += 2;
            }

            function setUint32(data) {
                view.setUint32(pos, data, true);
                pos += 4;
            }

            // Write interleaved data
            for (i = 0; i < buffer.numberOfChannels; i++) {
                channels.push(buffer.getChannelData(i));
            }

            while (pos < length) {
                for (i = 0; i < numOfChan; i++) {
                    sample = Math.max(-1, Math.min(1, channels[i][offset])); // clamp
                    sample = (0.5 + sample < 0 ? sample * 32768 : sample * 32767) | 0; // scale to 16-bit signed int
                    view.setInt16(pos, sample, true);
                    pos += 2;
                }
                offset++;
            }
            
            // Convert buffer to base64
            const a = new Uint8Array(buffer_);
            const b = a.reduce((data, byte) => data + String.fromCharCode(byte), '');
            return btoa(b);
        }

        async function base64ToAudioBuffer(base64, context) {
            const binary = atob(base64);
            const len = binary.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binary.charCodeAt(i);
            }
            return await context.decodeAudioData(bytes.buffer);
        }

        // === Video Export (WebM) ===
        saveMp4Btn.onclick = async () => {
            if (frames.length === 0) { showNotification('Nothing to save.'); return; }
            if (!window.MediaRecorder || !HTMLCanvasElement.prototype.captureStream) {
                showNotification('Video recording is not supported in this browser.'); return;
            }

            saveMp4Btn.disabled = true;
            saveMp4Btn.innerText = 'Recording...';
            showNotification("Starting video recording... please wait.", 3000);

            try {
                const { width, height } = frames[0].bgCanvas;
                const renderCanvas = document.createElement('canvas');
                renderCanvas.width = width;
                renderCanvas.height = height;
                const renderCtx = renderCanvas.getContext('2d');
                
                const videoStream = renderCanvas.captureStream(fps);
                let tracks = [...videoStream.getVideoTracks()];

                const allAudioClips = audioClips.flat();
                if (allAudioClips.length > 0) {
                    if (!audioContext) audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    
                    const totalAnimationDurationSeconds = frames.length / fps;
                    const offlineCtx = new OfflineAudioContext(1, totalAnimationDurationSeconds * audioContext.sampleRate, audioContext.sampleRate);

                    allAudioClips.forEach(clip => {
                        const source = offlineCtx.createBufferSource();
                        source.buffer = clip.buffer;
                        source.connect(offlineCtx.destination);
                        source.start(clip.timelineStart, clip.clipStart, clip.clipDuration);
                    });

                    const renderedAudioBuffer = await offlineCtx.startRendering();
                    const audioDestination = audioContext.createMediaStreamDestination();
                    const audioBufferSource = audioContext.createBufferSource();
                    audioBufferSource.buffer = renderedAudioBuffer;
                    audioBufferSource.connect(audioDestination);
                    audioBufferSource.start(0);

                    tracks.push(...audioDestination.stream.getAudioTracks());
                }
                
                const combinedStream = new MediaStream(tracks);
                const recorder = new MediaRecorder(combinedStream, { mimeType: 'video/webm' });

                const chunks = [];
                recorder.ondataavailable = e => {
                    if (e.data.size > 0) {
                        chunks.push(e.data);
                    }
                };

                const stopped = new Promise((resolve, reject) => {
                    recorder.onstop = () => {
                        combinedStream.getTracks().forEach(track => track.stop());
                        resolve();
                    };
                    recorder.onerror = event => {
                        combinedStream.getTracks().forEach(track => track.stop());
                        reject(event.error);
                    };
                });

                isRecording = true; // Set recording flag
                let currentRecordingFrameIndex = 0;
                let lastRecordedFrameTime = performance.now();

                function recordingLoop(currentTime) {
                    if (!isRecording) { // Se a grava√ß√£o foi cancelada, interrompa
                        if (recorder.state === 'recording' || recorder.state === 'paused') {
                            recorder.stop();
                        }
                        return;
                    }

                    // Desenhe um novo frame apenas se o tempo suficiente para o FPS atual tiver passado
                    if (currentTime - lastRecordedFrameTime >= frameDuration) {
                        lastRecordedFrameTime = currentTime;

                        if (currentRecordingFrameIndex < frames.length) {
                            renderCtx.fillStyle = '#FFFFFF';
                            renderCtx.fillRect(0, 0, width, height);
                            layerOrder.forEach(layer => renderCtx.drawImage(frames[currentRecordingFrameIndex][`${layer}Canvas`], 0, 0));
                            currentRecordingFrameIndex++;
                        } else {
                            // Todos os frames foram renderizados. Garanta que o gravador processe o(s) √∫ltimo(s) frame(s)
                            if (recorder.state === 'recording') {
                                // Um pequeno atraso fixo para garantir que o MediaRecorder tenha tempo para processar os dados
                                setTimeout(() => {
                                    recorder.stop();
                                    isRecording = false; // Sinaliza para o loop parar
                                }, 200); // 200ms de atraso fixo para o MediaRecorder
                            }
                            return; // Pare de solicitar frames de anima√ß√£o
                        }
                    }
                    recordingLoopId = requestAnimationFrame(recordingLoop);
                }

                recorder.start();
                recordingLoopId = requestAnimationFrame(recordingLoop); // Inicia o loop cont√≠nuo de renderiza√ß√£o e captura
                
                await stopped; // Espera o evento 'onstop' do gravador

                const blob = new Blob(chunks, { type: 'video/webm' });
                
                // Verifica se o blob est√° vazio, indicando falha na grava√ß√£o
                if (blob.size === 0) throw new Error("O v√≠deo gravado est√° com 0 bytes. A grava√ß√£o pode ter falhado ou nenhum quadro foi capturado.");

                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'animation.webm';
                a.click();
                URL.revokeObjectURL(url);
                showNotification('Video saved!', 3000);
            } catch (err) {
                console.error("Recording failed:", err);
                showNotification(err.message || "Ocorreu um erro durante a grava√ß√£o.", 5000);
            } finally {
                saveMp4Btn.disabled = false;
                saveMp4Btn.innerText = 'üé¨ Save as WebM';
                isRecording = false; // Garante que o flag seja resetado
                if (recordingLoopId) cancelAnimationFrame(recordingLoopId); // Interrompe qualquer requestAnimationFrame restante
            }
        };

        // This function exports the animation as a transparent WebM video.
        saveTransparentMp4Btn.onclick = async () => {
            if (frames.length === 0) { showNotification('Nothing to save.'); return; }
            if (!window.MediaRecorder || !HTMLCanvasElement.prototype.captureStream) {
                showNotification('Video recording is not supported in this browser.'); return;
            }

            saveTransparentMp4Btn.disabled = true;
            saveTransparentMp4Btn.innerText = 'Recording...';
            showNotification("Starting transparent video recording... please wait.", 3000);

            try {
                const { width, height } = frames[0].bgCanvas;
                const renderCanvas = document.createElement('canvas');
                renderCanvas.width = width;
                renderCanvas.height = height;
                const renderCtx = renderCanvas.getContext('2d', { alpha: true });
                
                const videoStream = renderCanvas.captureStream(fps);
                let tracks = [...videoStream.getVideoTracks()];

                const allAudioClips = audioClips.flat();
                if (allAudioClips.length > 0) {
                    if (!audioContext) audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    
                    const totalAnimationDurationSeconds = frames.length / fps;
                    const offlineCtx = new OfflineAudioContext(1, totalAnimationDurationSeconds * audioContext.sampleRate, audioContext.sampleRate);

                    allAudioClips.forEach(clip => {
                        const source = offlineCtx.createBufferSource();
                        source.buffer = clip.buffer;
                        source.connect(offlineCtx.destination);
                        source.start(clip.timelineStart, clip.clipStart, clip.clipDuration);
                    });

                    const renderedAudioBuffer = await offlineCtx.startRendering();
                    const audioDestination = audioContext.createMediaStreamDestination();
                    const audioBufferSource = audioContext.createBufferSource();
                    audioBufferSource.buffer = renderedAudioBuffer;
                    audioBufferSource.connect(audioDestination);
                    audioBufferSource.start(0);

                    tracks.push(...audioDestination.stream.getAudioTracks());
                }
                
                const combinedStream = new MediaStream(tracks);
                const mimeType = 'video/webm;codecs=vp9';
                if (!MediaRecorder.isTypeSupported(mimeType)) {
                    throw new Error("Transparent video (WebM/VP9) is not supported in this browser.");
                }
                const recorder = new MediaRecorder(combinedStream, { mimeType: mimeType });

                const chunks = [];
                recorder.ondataavailable = e => {
                    if (e.data.size > 0) {
                        chunks.push(e.data);
                    }
                };

                const stopped = new Promise((resolve, reject) => {
                    recorder.onstop = () => {
                        combinedStream.getTracks().forEach(track => track.stop());
                        resolve();
                    };
                    recorder.onerror = event => {
                        combinedStream.getTracks().forEach(track => track.stop());
                        reject(event.error);
                    };
                });

                isRecording = true; // Set recording flag
                let currentRecordingFrameIndex = 0;
                let lastRecordedFrameTime = performance.now();

                function recordingLoop(currentTime) {
                    if (!isRecording) { // Se a grava√ß√£o foi cancelada, interrompa
                        if (recorder.state === 'recording' || recorder.state === 'paused') {
                            recorder.stop();
                        }
                        return;
                    }

                    if (currentTime - lastRecordedFrameTime >= frameDuration) {
                        lastRecordedFrameTime = currentTime;

                        if (currentRecordingFrameIndex < frames.length) {
                            renderCtx.clearRect(0, 0, width, height); // Limpa o canvas para transpar√™ncia
                            layerOrder.forEach(layer => renderCtx.drawImage(frames[currentRecordingFrameIndex][`${layer}Canvas`], 0, 0));
                            currentRecordingFrameIndex++;
                        } else {
                            // Todos os frames foram renderizados. Garanta que o gravador processe o(s) √∫ltimo(s) frame(s)
                            if (recorder.state === 'recording') {
                                setTimeout(() => {
                                    recorder.stop();
                                    isRecording = false; // Sinaliza para o loop parar
                                }, 200); // 200ms de atraso fixo para o MediaRecorder
                            }
                            return; // Pare de solicitar frames de anima√ß√£o
                        }
                    }
                    recordingLoopId = requestAnimationFrame(recordingLoop);
                }

                recorder.start();
                recordingLoopId = requestAnimationFrame(recordingLoop); // Inicia o loop cont√≠nuo de renderiza√ß√£o e captura
                
                await stopped; // Espera o evento 'onstop' do gravador

                const blob = new Blob(chunks, { type: 'video/webm' });
                
                if (blob.size === 0) throw new Error("O v√≠deo gravado est√° com 0 bytes. A grava√ß√£o pode ter falhado ou nenhum quadro foi capturado.");

                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'animation_transparent.webm';
                a.click();
                URL.revokeObjectURL(url);
                showNotification('Transparent video saved! (as .webm)', 4000);
            } catch (err) {
                console.error("Recording failed:", err);
                showNotification(err.message || "Ocorreu um erro durante a grava√ß√£o.", 6000);
            } finally {
                saveTransparentMp4Btn.disabled = false;
                saveTransparentMp4Btn.innerText = 'üé¨ Save as Transparent WebM';
                isRecording = false; // Garante que o flag seja resetado
                if (recordingLoopId) cancelAnimationFrame(recordingLoopId); // Interrompe qualquer requestAnimationFrame restante
            }
        };

        // === Menu Dropdown Logic ===
        fileMenuBtn.onclick = (e) => {
            e.stopPropagation(); fileMenuDropdown.classList.toggle('hidden');
        };
        document.addEventListener('click', (e) => {
            if (!fileMenuContainer.contains(e.target)) fileMenuDropdown.classList.add('hidden');
        });

        // === Initialize Application ===
        function initialize() {
            setupAudioUI();
            addFrameBtn.click();
            resizeCanvases();
            checkScreenSize(); // Initial check on load
            updateToolUI();
            updateLayerButtonUI();
        }

        initialize();
    </script>
</body>
</html>
